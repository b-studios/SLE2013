Because of the delay, partial solutions will be


- Consider a macro running on an expression with nested subexpressions:

  val intermediateExpr = if (cond) { list map f } else { list map g }

  aMacro(intermediateExpr map h)

We said that aMacro can't know statically the what intermediateExpr is going to contain.

- Choose an example of boilerplate in the course lecture notes and try
  describing how macros could be used to automate the generation of such
  boilerplate.

- Macros can also be used:
  - for integrating external DSLs
  - for language virtualization
  - for
  Give an example of a possible usage scenario.

- Inside trace_impl, we have two different proposalsfor the body:

  def trace(x: Any): Unit = macro trace_impl
  def trace_impl(c: Context)(x: c.Expr[Any]): c.Expr[Unit] = {
    import c.universe._
    //Base version (1):
    //c.Expr(q"""println("The value of %s is %s" format (${show(x)}, $x))""")

    //Question: what's wrong if we write instead (2):
    //c.Expr(q"""println(${"The value of %s is %s" format (show(x), x)})""")
  }

Please analyze and describe the difference between the two pieces of code, in
terms of the different execution times we have discussed during the lecture.
Then, try out running both snippets, explain what happens and the difference.

Coding exercises:

- As mentioned, a drawback of HOAS interfaces is that the names chosen by the
  user are lost. Consider the following interface for the untyped lambda calculus:

   trait Term
   case class HOASFun(funBody: Term => Term, variableName: String) extends Term
   case class HOASApp(fun: Term, arg: Term) extends Term

try writing a macro

  fun(f: Term => Term): HOASFun

that, when invoked as fun(strangeName => body...), returns
HOASFun(strangeName => body..., "strangeName") by capturing the argument to the macro.
